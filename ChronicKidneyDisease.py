# -*- coding: utf-8 -*-
"""ChronicKidneyDisease.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BGUcIJm_LRj9w6ECnmZc8W0Fzo14LumK
"""

# Classifying patients whether they have Chronic Kidney Disease or not

#Libraries
import glob
import pandas as pd
import numpy as np
import keras as k
from keras.models import Sequential, load_model
from keras.layers import Dense
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, MinMaxScaler
import matplotlib.pyplot as plt

#Loading data
from google.colab import files
uploaded = files.upload()

df = pd.read_csv('kidney_disease.csv')

df.head()

df.shape

#Create a list of column names to keep
columns_to_keep = ['sg', 'al', 'sc', 'hemo', 'pcv', 'wbcc', 'rbcc', 'htn', 'classification']

#Dropping the columns which are not needed
df = df.drop( [col for col in df.columns if not col in columns_to_keep], axis=1 )

#Dropping rows with missing values
df = df.dropna(axis=0)

#Transforming columns with non-numeric data to numeric data
for column in df.columns:
  if df[column].dtype == np.number:
    continue
  else:
    df[column] = LabelEncoder().fit_transform(df[column])

df.head()

#Splitting data
X = df.drop(['classification'], axis=1)
y = df['classification']

#Feature Scaling
#MinMax method scales all the input features of the data between 0 and 1
x_scaler = MinMaxScaler()
x_scaler.fit(X)

column_names = X.columns
X[column_names] = x_scaler.transform(X)

#Splitting data into 80% training and 20% testing
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=True)

#Building the model
model = Sequential()
model.add(Dense(256, input_dim=len(X.columns), kernel_initializer=k.initializers.random_normal(seed=13), activation='relu'))
model.add(Dense(1, activation='hard_sigmoid'))

#Compiling the model
model.compile(loss='binary_crossentropy', optimizer='Adam', metrics=['accuracy'])

#Training the model
history = model.fit(X_train, y_train, epochs=2000, batch_size=X_train.shape[0])

#Saving model
model.save('ckd.model')

#Visualizing the models loss and accuracy
plt.plot(history.history['accuracy'])
plt.plot(history.history['loss'])
plt.title('Model Loss and Accuracy')
plt.ylabel('Accuracy & Loss')
plt.xlabel('epochs')

print('Shape of train data: ', X_train.shape)
print(' Shape of test data: ', X_test.shape)

#Actual and predicted values
pred = model.predict(X_test)
pred = [1 if y >= 0.5 else 0 for y in pred]

print(' Original: {0}'.format(", ".join(str(x) for x in y_test)))
print('Predicted: {0}'.format(", ".join(str(x) for x in pred)))

